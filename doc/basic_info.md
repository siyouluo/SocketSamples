# 基础知识

# IP地址（IP Address）
计算机分布在世界各地，要想和它们通信，必须要知道确切的位置。确定计算机位置的方式有多种，IP 地址是最常用的，例如，`114.114.114.114` 是国内第一个、全球第三个开放的 DNS 服务地址，`127.0.0.1` 是本机地址，`0.0.0.0`表示整个网络.

```md
在socket通信的服务器端有时会将监听的IP地址设置为`INADDR_ANY`, 该宏定义为`0.0.0.0`,在这里泛指本机的意思，也就是表示本机的所有IP.
因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。
比如一台电脑有3块网卡，分别连接三个网络，那么这台电脑就有3个ip地址了，如果某个应用程序需要监听某个端口，那应该监听哪个网卡地址的端口呢？
如果绑定某个具体的ip地址，那么只能监听所设置的ip地址所在的网卡的端口，其它两块网卡无法监听端口; 如果需要三个网卡都监听，那就需要绑定3个ip，也就等于需要管理3个套接字进行数据交换，过于繁琐.
所以出现`INADDR_ANY`，只需绑定INADDR_ANY，管理一个套接字就行，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。
```

其实，我们的计算机并不知道 IP 地址对应的地理位置，当要通信时，只是将 IP 地址封装到要发送的数据包中，交给路由器去处理。路由器有非常智能和高效的算法，很快就会找到目标计算机，并将数据包传递给它，完成一次单向通信。

目前大部分软件使用 IPv4 地址，但 IPv6 也正在被人们接受，尤其是在教育网中，已经大量使用。



#  端口（Port）
有了 IP 地址，虽然可以找到目标计算机，但仍然不能进行通信。一台计算机可以同时提供多种网络服务，例如Web服务、FTP服务（文件传输服务）、SMTP服务（邮箱服务）等，仅有 IP 地址，计算机虽然可以正确接收到数据包，但是却不知道要将数据包交给哪个网络程序来处理，所以通信失败。

为了区分不同的网络程序，计算机会为每个网络程序分配一个独一无二的端口号（Port Number），例如:  
- Web服务: 80
- FTP服务: 21
- SMTP服务: 25

端口（Port）是一个虚拟的、逻辑上的概念。可以将端口理解为一道门，数据通过这道门流入流出，每道门有不同的编号，就是端口号。

# 协议（Protocol）
协议（Protocol）就是网络通信的约定，通信的双方必须都遵守才能正常收发数据。协议有很多种，例如 TCP、UDP、IP 等，通信的双方必须使用同一协议才能通信。协议是一种规范，由计算机组织制定，规定了很多细节，例如，如何建立连接，如何相互识别等。
> 协议仅仅是一种规范，必须由计算机软件来实现。例如 IP 协议规定了如何找到目标计算机，那么各个开发商在开发自己的软件时就必须遵守该协议，不能另起炉灶。

所谓协议族（Protocol Family），就是一组协议（多个协议）的统称。最常用的是 TCP/IP 协议族，它包含了 TCP、IP、UDP、Telnet、FTP、SMTP 等上百个互为关联的协议，由于 TCP、IP 是两种常用的底层协议，所以把它们统称为 TCP/IP 协议族。 


# 数据传输方式
计算机之间有很多数据传输方式，各有优缺点，常用的有两种：SOCK_STREAM 和 SOCK_DGRAM。

1. SOCK_STREAM 表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常见的 http 协议就使用 SOCK_STREAM 传输数据，因为要确保数据的正确性，否则网页不能正常解析。

2. SOCK_DGRAM 表示无连接的数据传输方式。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为 SOCK_DGRAM 所做的校验工作少，所以效率比 SOCK_STREAM 高。

QQ 视频聊天和语音聊天就使用 SOCK_DGRAM 传输数据，因为首先要保证通信的效率，尽量减小延迟，而数据的正确性是次要的，即使丢失很小的一部分数据，视频和音频也可以正常解析，最多出现噪点或杂音，不会对通信质量有实质的影响。

> 注意：SOCK_DGRAM 没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。

有可能多种协议使用同一种数据传输方式，所以在 socket 编程中，需要同时指明`数据传输方式`和`协议`。


综上所述：`IP地址`和`端口`能够在广袤的互联网中定位到要通信的程序，`协议`和`数据传输方式`规定了如何传输数据，有了这些，两台计算机就可以通信了。

# TCP网络通信的基本流程
服务器和客户端程序的网络通信基本原理如下所述:  

- 服务器

1. 调用socket函数创建`监听socket`;
2. 调用bind函数将socket绑定到某个IP和端口的二元组上(`ip:port`);
3. 调用listen函数开启监听;
4. 当有客户端请求连接上来时,调用accept函数接受连接,产生一个新的socket(`客户端socket`);
5. 基于新产生的`客户端socket`调用send或recv函数,开始与客户端进行数据交流;
6. 与当前客户端的通信结束后,调用close函数关闭`客户端socket`;
7. 服务结束，且不再准备接受新的客户端连接时，调用close函数关闭`监听socket`.

- 客户端

1. 调用socket函数创建`客户端socket`;
2. 调用connect函数尝试连接服务器;
3. 连接成功后调用send或recv函数,开始与服务器进行数据交流;
4. 通信结束后,调用close函数关闭`客户端socket`.

<div align="center">
<img src="images/TCP网络通信流程图.jpg" alt="TCP网络通信流程图.jpg" height=400/>
</div>

# 参考
- [socket编程/socket简介 - C语言中文网](http://c.biancheng.net/cpp/html/3029.html)
- [C++服务器开发精髓 - 张远龙](https://gitee.com/balloonwj/mybooksources)

